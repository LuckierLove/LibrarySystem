# 图书借阅管理系统 - 设计文档

## 一、功能设计说明

### 1.1 借书功能流程逻辑

借书功能是图书管理系统的核心业务之一，其完整流程如下：

#### 1.1.1 用户操作流程
1. **用户登录系统**：用户使用账号密码登录系统，系统验证用户身份
2. **浏览图书列表**：在主界面查看所有可借图书，支持关键词搜索
3. **选择图书**：在表格中选择想要借阅的图书
4. **点击借书按钮**：触发借书操作
5. **输入借阅天数**：系统弹出对话框，用户输入借阅天数（建议30天）
6. **确认借阅**：系统执行借书逻辑并返回结果

#### 1.1.2 系统处理流程
1. **前端验证**
   - 检查用户是否选中了图书
   - 检查图书库存是否充足（available_quantity > 0）
   - 验证借阅天数的合法性（1-365天）

2. **业务逻辑处理**（BorrowService.borrowBook方法）
   - 查询图书信息，验证图书是否存在
   - 检查图书库存是否大于0
   - 查询用户是否已借阅该图书（防止重复借阅）
   - 计算应还日期（当前日期 + 借阅天数）
   - 创建借阅记录（插入borrow_records表）
   - 减少图书可借数量（更新books表的available_quantity字段）

3. **数据库操作**
   - INSERT操作：在borrow_records表中插入一条新记录
   - UPDATE操作：更新books表中对应图书的available_quantity字段

4. **结果反馈**
   - 成功：显示成功消息，刷新图书列表
   - 失败：显示错误提示，不修改数据

#### 1.1.3 业务规则约束
- 图书库存必须大于0才能借阅
- 用户不能重复借阅同一本图书（必须先归还）
- 借阅天数限制在1-365天之间
- 借阅记录自动记录借阅日期和应还日期

### 1.2 还书功能流程逻辑

还书功能用于归还已借阅的图书，其完整流程如下：

#### 1.2.1 用户操作流程
1. **选择已借图书**：在图书列表中选择要归还的图书
2. **点击还书按钮**：触发还书操作
3. **确认归还**：系统弹出确认对话框，用户确认归还
4. **完成归还**：系统执行还书逻辑并返回结果

#### 1.2.2 系统处理流程
1. **前端验证**
   - 检查用户是否选中了图书
   - 弹出确认对话框，防止误操作

2. **业务逻辑处理**（BorrowService.returnBook方法）
   - 查找用户借阅该图书的记录（状态为"借阅中"或"已逾期"）
   - 更新借阅记录状态为"已归还"
   - 记录实际归还日期（return_date）
   - 增加图书可借数量（available_quantity + 1）

3. **数据库操作**
   - UPDATE操作：更新borrow_records表中的status和return_date字段
   - UPDATE操作：更新books表中的available_quantity字段

4. **结果反馈**
   - 成功：显示成功消息，刷新图书列表
   - 失败：显示错误提示（如未找到借阅记录）

#### 1.2.3 业务规则约束
- 只能归还当前用户已借阅的图书
- 归还后自动记录实际归还时间
- 归还后图书库存自动增加
- 借阅记录状态更新为"已归还"

---

## 二、类图说明

### 2.1 系统架构概述

本系统采用经典的**分层架构**设计，分为四层：

```
展现层 (UI Layer)
    ↓
业务逻辑层 (Service Layer)
    ↓
数据访问层 (DAO Layer)
    ↓
实体层 (Entity Layer)
```

### 2.2 核心类关系说明

#### 2.2.1 实体层（Entity）
- **Book**：图书实体类，包含图书的所有属性
- **User**：用户实体类，包含用户账号信息
- **BorrowRecord**：借阅记录实体类，关联用户和图书

**关系**：BorrowRecord关联User和Book（多对一关系）

#### 2.2.2 数据访问层（DAO）
- **BookDao**：图书数据访问对象，负责图书的CRUD操作
- **UserDao**：用户数据访问对象，负责用户的CRUD和登录验证
- **BorrowRecordDao**：借阅记录数据访问对象，负责借阅记录的管理

**关系**：每个DAO类对应一个Entity类，提供数据库操作方法

#### 2.2.3 业务逻辑层（Service）
- **BookService**：图书业务服务，调用BookDao实现图书管理功能
- **UserService**：用户业务服务，调用UserDao实现用户管理和登录功能
- **BorrowService**：借阅业务服务，调用BookDao和BorrowRecordDao实现借还书逻辑

**关系**：
- BookService → BookDao
- UserService → UserDao
- BorrowService → BookDao + BorrowRecordDao

#### 2.2.4 展现层（UI）
- **LoginFrame**：登录界面，调用UserService进行登录验证
- **MainFrame**：主界面，调用BookService和BorrowService实现图书浏览和借还书功能
- **BorrowRecordDialog**：借阅记录对话框，调用BorrowService查询借阅记录

**关系**：
- LoginFrame → UserService
- MainFrame → BookService + BorrowService
- BorrowRecordDialog → BorrowService

#### 2.2.5 工具类
- **DBUtil**：数据库连接工具类，提供数据库连接管理和资源释放功能

**关系**：所有DAO类都依赖DBUtil获取数据库连接

### 2.3 调用关系总结

```
UI层 → Service层 → DAO层 → Entity层
                      ↓
                   DBUtil（数据库）
```

**典型调用链示例（借书操作）**：
1. 用户点击MainFrame的"借书"按钮
2. MainFrame.handleBorrow() 调用 BorrowService.borrowBook()
3. BorrowService.borrowBook() 调用 BookDao.findById() 和 BorrowRecordDao.add()
4. BookDao和BorrowRecordDao通过DBUtil获取数据库连接
5. 执行SQL操作，返回结果
6. 结果层层返回到UI层，显示给用户

---

## 三、核心代码解析

### 3.1 借书按钮点击事件处理代码

以下是MainFrame类中借书按钮的核心事件处理代码，包含详细注释：

```java
/**
 * 处理借书操作
 * 核心业务逻辑：
 * 1. 检查是否选中了图书
 * 2. 获取选中图书的ID
 * 3. 弹出对话框让用户输入借阅天数
 * 4. 调用BorrowService执行借书逻辑
 * 5. 显示操作结果并刷新表格
 */
private void handleBorrow() {
    // ========== 步骤1：检查是否选中了图书 ==========
    // 获取JTable中当前选中的行索引，如果没有选中则返回-1
    int selectedRow = bookTable.getSelectedRow();
    if (selectedRow == -1) {
        // 未选中任何图书，弹出警告提示
        JOptionPane.showMessageDialog(this, 
            "请先选择要借阅的图书！", 
            "提示", 
            JOptionPane.WARNING_MESSAGE);
        return; // 终止方法执行
    }
    
    // ========== 步骤2：获取选中图书的信息 ==========
    // 从表格模型中获取选中行的各列数据
    Integer bookId = (Integer) tableModel.getValueAt(selectedRow, 0); // 第0列：图书ID
    String bookName = (String) tableModel.getValueAt(selectedRow, 1); // 第1列：书名
    Integer availableQuantity = (Integer) tableModel.getValueAt(selectedRow, 6); // 第6列：可借数量
    
    // ========== 前置验证：检查库存是否充足 ==========
    if (availableQuantity <= 0) {
        // 库存为0，无法借阅
        JOptionPane.showMessageDialog(this, 
            "该图书暂无库存，无法借阅！", 
            "库存不足", 
            JOptionPane.WARNING_MESSAGE);
        return; // 终止方法执行
    }
    
    // ========== 步骤3：弹出对话框输入借阅天数 ==========
    // 使用JOptionPane.showInputDialog弹出输入对话框
    // 默认值为"30"，表示建议借阅30天
    String daysStr = JOptionPane.showInputDialog(this, 
        "请输入借阅天数（建议30天）:", 
        "30");
    
    // 用户点击取消按钮时，daysStr为null
    if (daysStr == null) {
        return; // 用户取消操作，终止方法执行
    }
    
    // ========== 验证输入的借阅天数 ==========
    int borrowDays;
    try {
        // 将字符串转换为整数
        borrowDays = Integer.parseInt(daysStr);
        
        // 验证借阅天数的合法性：必须在1-365天之间
        if (borrowDays <= 0 || borrowDays > 365) {
            JOptionPane.showMessageDialog(this, 
                "借阅天数必须在1-365天之间！", 
                "输入错误", 
                JOptionPane.ERROR_MESSAGE);
            return; // 输入不合法，终止方法执行
        }
    } catch (NumberFormatException e) {
        // 转换失败，说明用户输入的不是有效数字
        JOptionPane.showMessageDialog(this, 
            "请输入有效的数字！", 
            "输入错误", 
            JOptionPane.ERROR_MESSAGE);
        return; // 输入格式错误，终止方法执行
    }
    
    // ========== 步骤4：调用业务逻辑层执行借书操作 ==========
    // 调用BorrowService的borrowBook方法
    // 参数：当前登录用户ID、图书ID、借阅天数
    // 返回值：如果成功返回null，失败返回错误消息字符串
    String errorMessage = borrowService.borrowBook(
        currentUser.getUserId(),  // 当前登录用户的ID
        bookId,                   // 要借阅的图书ID
        borrowDays                // 借阅天数
    );
    
    // ========== 步骤5：处理操作结果 ==========
    if (errorMessage == null) {
        // 借书成功（errorMessage为null表示没有错误）
        JOptionPane.showMessageDialog(this, 
            "借书成功！\n图书名称：" + bookName + "\n借阅天数：" + borrowDays + "天", 
            "成功", 
            JOptionPane.INFORMATION_MESSAGE);
        
        // 刷新表格数据，以显示最新的图书库存信息
        loadBookData();
    } else {
        // 借书失败（errorMessage不为null，包含具体错误信息）
        JOptionPane.showMessageDialog(this, 
            errorMessage, // 显示具体的错误原因
            "借书失败", 
            JOptionPane.ERROR_MESSAGE);
    }
}
```

**代码设计亮点**：
1. **职责分离**：UI层只负责界面交互和数据展示，业务逻辑由Service层处理
2. **充分验证**：在调用业务逻辑前进行多重验证（选中检查、库存检查、输入验证）
3. **用户友好**：提供清晰的提示信息，默认值减少用户输入
4. **错误处理**：通过try-catch捕获异常，防止程序崩溃
5. **即时反馈**：操作完成后立即刷新界面，让用户看到最新状态

### 3.2 借书业务逻辑核心代码

以下是BorrowService类中borrowBook方法的核心实现，包含详细注释：

```java
/**
 * 借书操作
 * 业务规则：
 * 1. 检查图书库存是否充足（available_quantity > 0）
 * 2. 检查用户是否已经借阅该图书（避免重复借阅）
 * 3. 创建借阅记录
 * 4. 减少图书的可借数量
 * 
 * @param userId 用户ID
 * @param bookId 图书ID
 * @param borrowDays 借阅天数
 * @return 成功返回null，失败返回错误消息
 */
public String borrowBook(Integer userId, Integer bookId, int borrowDays) {
    // ========== 步骤1：查询图书信息 ==========
    // 通过BookDao从数据库中查询图书详细信息
    Book book = bookDao.findById(bookId);
    
    // 验证图书是否存在
    if (book == null) {
        return "图书不存在！"; // 返回错误消息
    }
    
    // ========== 步骤2：检查图书库存 ==========
    // 调用Book实体类的isAvailable()方法
    // 该方法判断available_quantity是否大于0
    if (!book.isAvailable()) {
        return "图书库存不足，暂时无法借阅！"; // 库存不足，返回错误消息
    }
    
    // ========== 步骤3：检查用户是否已经借阅该图书 ==========
    // 调用BorrowRecordDao查询用户是否有未归还的借阅记录
    // 这是为了防止用户重复借阅同一本书
    BorrowRecord existingRecord = borrowRecordDao.findBorrowingRecord(userId, bookId);
    
    if (existingRecord != null) {
        // 用户已经借阅了这本书，且尚未归还
        return "您已经借阅了这本书，请先归还后再借！";
    }
    
    // ========== 步骤4：计算应还日期 ==========
    // 使用Calendar类计算应还日期
    Calendar calendar = Calendar.getInstance(); // 获取当前日期
    calendar.add(Calendar.DAY_OF_MONTH, borrowDays); // 增加指定的天数
    Date dueDate = new Date(calendar.getTimeInMillis()); // 转换为Date对象
    
    // ========== 步骤5：创建借阅记录 ==========
    // 创建BorrowRecord对象，包含用户ID、图书ID和应还日期
    // 借阅日期和状态会在数据库层自动设置
    BorrowRecord record = new BorrowRecord(userId, bookId, dueDate);
    
    // 调用BorrowRecordDao将借阅记录插入数据库
    boolean recordAdded = borrowRecordDao.add(record);
    
    if (!recordAdded) {
        // 插入失败，可能是数据库异常
        return "创建借阅记录失败，请重试！";
    }
    
    // ========== 步骤6：减少图书可借数量 ==========
    // 计算新的可借数量：当前可借数量 - 1
    int newAvailableQuantity = book.getAvailableQuantity() - 1;
    
    // 调用BookDao更新数据库中的available_quantity字段
    boolean quantityUpdated = bookDao.updateAvailableQuantity(bookId, newAvailableQuantity);
    
    if (!quantityUpdated) {
        // 更新失败，但借阅记录已经创建
        // 这种情况下数据不一致，需要人工处理或回滚
        return "更新图书库存失败，请联系管理员！";
    }
    
    // ========== 操作成功，返回null ==========
    // 所有步骤都成功完成，返回null表示没有错误
    return null;
}
```

**业务逻辑设计亮点**：
1. **原子性操作**：先创建借阅记录，再更新库存，保证数据一致性
2. **防重复借阅**：通过查询现有借阅记录，避免用户重复借阅
3. **多重验证**：图书存在性、库存充足性、重复借阅等多重检查
4. **错误处理**：每个可能出错的步骤都有明确的错误提示
5. **返回值设计**：成功返回null，失败返回具体错误信息，便于UI层处理

---

## 四、数据库设计特色

### 4.1 三张核心表
1. **books**：图书信息表，包含total_quantity和available_quantity两个字段
2. **users**：用户信息表，区分管理员和普通读者
3. **borrow_records**：借阅记录表，通过外键关联用户和图书

### 4.2 设计亮点
- 使用CHECK约束确保可借数量不超过总数量
- 使用外键保证数据完整性
- 使用索引提高查询效率
- 使用ENUM类型规范状态值
- 包含测试数据，方便系统测试

---

## 五、系统特色总结

1. **分层架构清晰**：严格遵循四层架构，职责分明
2. **代码注释详细**：每个方法都有JavaDoc注释，变量名见名知意
3. **业务逻辑严密**：借还书功能包含完善的验证和错误处理
4. **用户体验友好**：界面美观，操作提示清晰
5. **使用现代工具**：Lombok简化实体类开发，Maven管理依赖
6. **符合工程规范**：遵循软件工程方法论，文档完善

---

**文档编写者**：图书管理系统开发组  
**文档版本**：1.0.0  
**最后更新**：2025-12-28
